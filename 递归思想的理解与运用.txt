
递归思想的理解与运用

  最典型最易理解的递归算法是数学的求阶乘运算：
  阶乘 1! = 1; 2! = 2*1; 3! = 3*2*1; 4! = 4*3*2*1; 那么，我们可以非常自然地想到：1! = 1; 2! = 2*(1!); 3! = 3*(2!); 4! = 4*(3!); 那么假如你要去求4的阶乘，那你不得不去求3！，求3！不得不去求2！，最后1！调用触底反弹，计算出来1！= 1， 反代求出 2！，再把 2！代到 3！中去，3！代到 4！中去求出最后结果，这里没有用通用式 n! = n*((n-1)!); 就是用最小的数简单地说明这个道理：所如 jc(4); 代码求阶乘的方法，你不得不去求 jc(3), jc(2), jc(1)。 那么你会在jc(4)的方法里去调用它自身的方法，这就是递归。代码如下：

   public long jc(long i){
      if(i < 1)
         return 1; 
      else {
         return jc(i-1)*i;
      }
   }

   if(i < 1)是退出的条件，方法的调用总有结束点，否则为递归分配的内存栈资源总有耗尽的时候，这里你所调用的参数，是一步步减下来，总有减到0的时候，那时候直接返回1，然后，通过计算机刚才栈里边的状态记忆，一步步反代。

   递归的官方定义：一个函数（或者称为方法）在它的函数体内调用它自身称为递归调用。 这种函数称为递归函数。有时候使用递归函数能较大的方便工作，但要防止进入死循环。用程序设计的角度来这样阐明：

主程序调用子程序A，子程序A调用子程序B，这个过程实际上是： 

（1）当主程序执行到调用子程序A语句时，系统保存一些必要的现场数据，然后执行类似于BASIC语言的GOTO语句，跳转到子程序A。
（2）当子程序A执行到调用子程序B语句时，系统作法如上，跳转到子程序B。 
（3）子程序B执行完所有语句后，跳转回子程序A调用子程序B语句的下一条语句（我这忽略了返回值处理）。
（4）子程序A执行完后，跳转回主程序调用子程序A语句的下一条语句。
（5）主程序执行到结束。 
